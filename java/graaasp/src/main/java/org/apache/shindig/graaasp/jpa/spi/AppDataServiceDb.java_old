/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.apache.shindig.graaasp.jpa.spi;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.inject.Inject;
import com.google.common.collect.MapMaker;


import org.apache.shindig.auth.SecurityToken;
import org.apache.shindig.common.util.ImmediateFuture;
import org.apache.shindig.protocol.DataCollection;
import org.apache.shindig.protocol.ProtocolException;
import org.apache.shindig.graaasp.jpa.ApplicationDataMapDb;
import org.apache.shindig.graaasp.jpa.spi.JPQLUtils;
import org.apache.shindig.graaasp.jpa.spi.SPIUtils;
import org.apache.shindig.social.opensocial.spi.AppDataService;
import org.apache.shindig.social.opensocial.spi.GroupId;
import org.apache.shindig.social.opensocial.spi.UserId;

import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;

import javax.persistence.EntityManager;
import javax.servlet.http.HttpServletResponse;

/**
 *
 */
public class AppDataServiceDb implements AppDataService {

  private EntityManager entityManager;

  @Inject
  public AppDataServiceDb(EntityManager entityManager) {
    this.entityManager = entityManager;
  }

  /**
   * {@inheritDoc}
   */
  public Future<Void> deletePersonData(UserId userId, GroupId groupId, String appId,
      Set<String> fields, SecurityToken token) throws ProtocolException {

    List<ApplicationDataMapDb> dataMaps = getDataMap(userId, groupId, appId, token);
    for (ApplicationDataMapDb adm : dataMaps) {
      for (String f : fields) {
        adm.getValues().remove(f);
      }
    }
     // TODO How should transactions be managed? Should samples be using warp-persist instead?
     if (!entityManager.getTransaction().isActive()) {
       entityManager.getTransaction().begin();
     }

    entityManager.flush();
    entityManager.getTransaction().commit();

    return ImmediateFuture.newInstance(null);
  }

  /**
   * @param userId
   * @param groupId
   * @param appId
   * @param token
   * @return
   */
  private List<ApplicationDataMapDb> getDataMap(UserId userId, GroupId groupId, String appId,
      SecurityToken token) {
    List<Long> paramList = Lists.newArrayList();
    String uid = SPIUtils.getUserList(userId, token);
    String contextType = "";
    long id = 0;
    if(uid.startsWith("p_")){
      // appdata for a person
      id = Long.parseLong(uid.replaceFirst("p_",""));
      paramList.add(id);
      contextType = "User";
    }else{ 
      if(uid.startsWith("s_")){
        // appdata for a space
        id = Long.parseLong(uid.replaceFirst("2_",""));
        paramList.add(id);
        contextType = "Space";
      }else{
        //throw exception in Protocol: id should contain a prefix "p_" or "s_"
        throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND ,"id should contain a prefix 'p_' (for people) or 's_' (for spaces)");
      }
    }
    
    
    int lastParam = 1;
    StringBuilder sb = new StringBuilder();

    switch (groupId.getType()) {
    case all:
      // userId translates into all contacts
      sb.append(ApplicationDataMapDb.FINDBY_ALL_GROUP);
      sb.append(" and am.contextId = ?").append(lastParam);
      lastParam++;
      break;
    case deleted:
      // ignored
      break;
    case friends:
      sb.append(ApplicationDataMapDb.FINDBY_FRIENDS_GROUP);
      sb.append(" and am.contextId = ?").append(lastParam);
      lastParam++;
      // userId translates into all friends
      break;
    case groupId:
      sb.append(ApplicationDataMapDb.FINDBY_GROUP_GROUP);
      sb.append(" and am.contextId = ?").append(lastParam);
      lastParam++;
      sb.append(" and g.id = ?").append(lastParam);
      paramList.add(Long.parseLong(groupId.getGroupId()));
      lastParam++;
      // userId translates into friends within a group
      break;
    default: // including self
      // userId is the user Id
      sb.append(ApplicationDataMapDb.FINDBY_SELF_GROUP);
      sb.append(" am.contextId = ?").append(lastParam);
      sb.append(" and am.contextType = '").append(contextType).append("'");
      lastParam++;
      break;

    }
    sb.append(" and am.AppId = ?").append(lastParam);
    lastParam++;
    paramList.add(Long.parseLong(appId));
    List<ApplicationDataMapDb> dataMaps = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, null);
    
    if (dataMaps.isEmpty()) { // if dataMap does not exist, create one
      List<ApplicationDataMapDb> list = new ArrayList<ApplicationDataMapDb>();
      ApplicationDataMapDb a = new ApplicationDataMapDb();
      a.setContextId(id);
      a.setContextType(contextType);
      a.setAppId(Long.parseLong(appId));

      // a.setValues(null);
      
      if (!entityManager.getTransaction().isActive()) {
        entityManager.getTransaction().begin();
      }
      entityManager.persist(a);
      entityManager.getTransaction().commit();
      
      list.add(a);
      dataMaps = list;
      
      dataMaps = JPQLUtils.getListQuery(entityManager, sb.toString(), paramList, null);
    }
    return dataMaps;

  }

  /**
   * {@inheritDoc}
   */
  public Future<DataCollection> getPersonData(Set<UserId> userIds, GroupId groupId, String appId,
      Set<String> fields, SecurityToken token) throws ProtocolException {
    List<String> paramList = SPIUtils.getUserList(userIds, token);
    int lastParam = 1;
    StringBuilder sb = new StringBuilder();

    switch (groupId.getType()) {
    case all:
      // userId translates into all contacts
      sb.append(ApplicationDataMapDb.FINDBY_ALL_GROUP);
      lastParam = JPQLUtils.addInClause(sb, "am", "contextId", lastParam, paramList.size());
      break;
    case deleted:
      // ignored
      break;
    case friends:
      sb.append(ApplicationDataMapDb.FINDBY_FRIENDS_GROUP);
      lastParam = JPQLUtils.addInClause(sb, "p", "id", lastParam, paramList.size());
      sb.append(')');
      // userId translates into all friends
      break;
    case groupId:
      sb.append(ApplicationDataMapDb.FINDBY_GROUP_GROUP);
      lastParam = JPQLUtils.addInClause(sb, "am", "contextId", lastParam, paramList.size());
      sb.append(" and g.id = ?").append(lastParam);
      paramList.add(groupId.getGroupId());
      lastParam++;
      // userId translates into friends within a group
      break;
    default: // including self
      // userId is the user Id
      sb.append(ApplicationDataMapDb.FINDBY_SELF_GROUP);
      String uid = paramList.get(lastParam-1);
      // lastParam = JPQLUtils.addInClause(sb, "am", "contextId", lastParam, paramList.size());
      
      if(uid.startsWith("p_")){
        // appdata for a person
        sb.append(" am.contextId = ").append(uid.replaceFirst("p_",""));
        sb.append(" and am.contextType = 'User'");
      }else{ 
        if(uid.startsWith("s_")){
          // appdata for a space
          sb.append(" am.contextId = ").append(uid.replaceFirst("s_",""));
          sb.append(" and am.contextType = 'Space'");
        }else{
          //throw exception in Protocol: id should contain a prefix "p_" or "s_"
          throw new ProtocolException(HttpServletResponse.SC_NOT_FOUND ,"id should contain a prefix 'p_' (for people) or 's_' (for spaces)");
        }
      }
      lastParam++;
      break;

    }
    sb.append(" and am.application_id = ").append(lastParam);
    lastParam++;
    paramList.add(appId);

    // load the map up
    List<ApplicationDataMapDb> dataMaps = JPQLUtils.getListQuery(entityManager, sb.toString(),
        paramList, null);
    Map<String, Map<String, String>> results = new HashMap<String, Map<String, String>>();

    // only add in the fields
    if (fields == null || fields.isEmpty()) {
      for (ApplicationDataMapDb adm : dataMaps) {
        // TODO: should take spaces into account
        String contextId = String.valueOf(adm.getContextId());
        results.put(contextId, adm.getValues());
      }
    } else {
      for (ApplicationDataMapDb adm : dataMaps) {
        Map<String, String> m = Maps.newHashMap();
        for (String f : fields) {
          String value = adm.getValues().get(f);
          if (null != value) {
            m.put(f, value);
          }
        }
        // TODO: should take spaces into account
        String contextId = String.valueOf(adm.getContextId());
        results.put(contextId, m);
      }
    }
    DataCollection dc = new DataCollection(results);
    return ImmediateFuture.newInstance(dc);
  }

  /**
   * {@inheritDoc}
   */
  public Future<Void> updatePersonData(UserId userId, GroupId groupId, String appId,
      Set<String> fields, Map<String, String> values, SecurityToken token)
      throws ProtocolException {
    List<ApplicationDataMapDb> dataMaps = getDataMap(userId, groupId, appId, token);
    for (ApplicationDataMapDb adm : dataMaps) {
      for (String f : fields) {
        adm.getValues().put(f, values.get(f));
      }
    }
    
    // TODO How should transactions be managed? Should samples be using warp-persist instead?
    if (!entityManager.getTransaction().isActive()) {
      entityManager.getTransaction().begin();
    }
    for (ApplicationDataMapDb adm : dataMaps) {
      entityManager.persist(adm);
    }
    
    entityManager.getTransaction().commit();

    return ImmediateFuture.newInstance(null);
  }

}
